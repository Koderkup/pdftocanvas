<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>PDF Unicode Editor ‚Äî –¢–æ—á–Ω—ã–π —ç–∫—Å–ø–æ—Ä—Ç</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: sans-serif; background: #f2f2f2; text-align: center; padding: 1rem; }
    canvas { border: 1px solid #ccc; margin: 1rem auto; display: block; cursor: crosshair; }
    .controls, .editor {
      margin: 1rem auto;
      display: flex; flex-wrap: wrap;
      justify-content: center; gap: 0.5rem; max-width: 800px;
    }
    input, button, textarea { font-size: 1rem; padding: 0.5rem; }
    .status { margin-top: 1rem; font-size: 1rem; color: #333; }
    button:disabled { background: #ccc; cursor: not-allowed; }
  </style>
</head>
<body>

<h2>üìÑ PDF Unicode Editor ‚Äî –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã, –∫–∞–∫ –Ω–∞ —ç–∫—Ä–∞–Ω–µ</h2>

<input type="file" id="pdf-file" accept="application/pdf" />
<button id="load-btn">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å PDF</button>

<canvas id="pdf-canvas"></canvas>

<div class="controls">
  <button id="prev-page">‚¨Ö</button>
  <button id="next-page">‚û°</button>
  <button id="zoom-in">üîç+</button>
  <button id="zoom-out">üîé-</button>
  <button id="save-btn" disabled>üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å PDF</button>
</div>

<div class="status">–°—Ç—Ä–∞–Ω–∏—Ü–∞: <span id="page-num">‚Äì</span> / <span id="page-count">‚Äì</span></div>

<h3>‚úèÔ∏è –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç, –∑–∞—Ç–µ–º –∫–ª–∏–∫–Ω–∏—Ç–µ –ø–æ —Å—Ç—Ä–∞–Ω–∏—Ü–µ</h3>
<div class="editor">
  <textarea id="text-input" placeholder="–ü—Ä–∏–≤–µ—Ç üòä ÿ£ŸáŸÑÿßŸã" rows="3" cols="30"></textarea>
</div>
<button id="clear-cache">üßπ –û—á–∏—Å—Ç–∏—Ç—å –∫—ç—à</button>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.6.172/pdf.min.js"></script>
<script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
<script src="https://unpkg.com/@pdf-lib/fontkit@0.0.4/dist/fontkit.umd.js"></script>

<script>
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.6.172/pdf.worker.min.js";
let isRendering = false;

function base64ToUint8(base64) {
  const binary = atob(base64);
  const len = binary.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
}

function uint8ToBase64(uint8) {
  let binary = "";
  const chunkSize = 8192;
  for (let i = 0; i < uint8.length; i += chunkSize) {
    const chunk = uint8.slice(i, i + chunkSize);
    binary += String.fromCharCode.apply(null, Array.from(chunk));
  }
  return btoa(binary);
}


async function getValidPDFBytes() {
  const result = await loadPDFFromDB("pdfRaw");
  if (!result) return null;

  // üëâ –ï—Å–ª–∏ Blob ‚Äî –∏–∑–≤–ª–µ—á—å ArrayBuffer
  if (result instanceof Blob) {
    const buffer = await result.arrayBuffer();
    return new Uint8Array(buffer);
  }

  // üëâ –ï—Å–ª–∏ Uint8Array ‚Äî –≤–µ—Ä–Ω—É—Ç—å –∫–∞–∫ –µ—Å—Ç—å
  if (result instanceof Uint8Array) return result;

  // üëâ –ï—Å–ª–∏ ArrayBuffer ‚Äî –æ–±–µ—Ä–Ω—É—Ç—å
  if (result instanceof ArrayBuffer) return new Uint8Array(result);

  // üëâ –ï—Å–ª–∏ –æ–±—ã—á–Ω—ã–π –æ–±—ä–µ–∫—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∏–∑ structured clone)
  if (typeof result === "object" && result.byteLength !== undefined) {
    return new Uint8Array(Object.values(result));
  }

  console.warn("‚ö†Ô∏è –ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π —Ç–∏–ø PDF –∏–∑ IndexedDB:", result);
  return null;
}


function openPDFDatabase() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("PDFStorage", 1);
    request.onupgradeneeded = () => {
      const db = request.result;
      if (!db.objectStoreNames.contains("files")) {
        db.createObjectStore("files");
      }
    };
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

async function clearPDFCache() {
  const db = await openPDFDatabase();
  const tx = db.transaction("files", "readwrite");
  tx.objectStore("files").delete("pdfRaw"); // —É–¥–∞–ª—è–µ–º PDF
  localStorage.removeItem("textItems");     // —É–¥–∞–ª—è–µ–º —Ç–µ–∫—Å—Ç
}


async function savePDFToDB(key, bytes) {
  const db = await openPDFDatabase();
  const tx = db.transaction("files", "readwrite");
  tx.objectStore("files").put(bytes, key);
  return tx.complete;
}

async function loadPDFFromDB(key) {
  const db = await openPDFDatabase();

  return new Promise((resolve, reject) => {
    const tx = db.transaction("files", "readonly");
    const store = tx.objectStore("files");
    const request = store.get(key);

    request.onsuccess = () => {
      resolve(request.result);
    };

    request.onerror = () => {
      reject(request.error);
    };
  });
}

  const canvas = document.getElementById("pdf-canvas");
  const ctx = canvas.getContext("2d");

  let pdfDoc = null;
  let originalFile = null;
  let pageNum = 1;
  let pageCount = 0;
  let scale = 1.2;
  let textItems = [];
  let currentViewport = null;

  function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
  const words = text.split(' ');
  let line = '';
  for (let n = 0; n < words.length; n++) {
    const testLine = line + words[n] + ' ';
    const metrics = ctx.measureText(testLine);
    const testWidth = metrics.width;
    if (testWidth > maxWidth && n > 0) {
      ctx.fillText(line, x, y);
      line = words[n] + ' ';
      y += lineHeight;
    } else {
      line = testLine;
    }
  }
  ctx.fillText(line, x, y);
}



 async function renderPage(n) {
  if (isRendering) return; // –Ω–µ —Ä–µ–Ω–¥–µ—Ä–∏–º, –µ—Å–ª–∏ —É–∂–µ –∏–¥—ë—Ç —Ä–µ–Ω–¥–µ—Ä
  isRendering = true;

  const page = await pdfDoc.getPage(n);
  currentViewport = page.getViewport({ scale });
  canvas.width = currentViewport.width;
  canvas.height = currentViewport.height;
  await page.render({ canvasContext: ctx, viewport: currentViewport }).promise;

  document.getElementById("page-num").textContent = n;

  ctx.font = "16px sans-serif";
  ctx.fillStyle = "black";
  ctx.textBaseline = "top";

  textItems
  .filter(t => t.page === pageNum)
  .forEach(item => {
    // –ü–µ—Ä–µ–≤–æ–¥–∏–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –∞–±—Å–æ–ª—é—Ç–Ω—ã–µ
    const x = item.relativeX * canvas.width;
    const y = item.relativeY * canvas.height;

    wrapText(ctx, item.text, x, y, 300, 20);
  });


  isRendering = false;
}



(async () => {
  const bytes = await getValidPDFBytes();
  if (!bytes) return;

  try {
    pdfDoc = await pdfjsLib.getDocument({ data: bytes }).promise;
    pageCount = pdfDoc.numPages;
    pageNum = 1;
    document.getElementById("page-count").textContent = pageCount;

    const savedText = localStorage.getItem("textItems");
    if (savedText) {
      textItems = JSON.parse(savedText);
    }

    await renderPage(pageNum);
    document.getElementById("save-btn").disabled = false;
  } catch (e) {
    alert("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å PDF: " + e.message);
    console.error(e);
  }
})();

  document.getElementById("load-btn").onclick = () => {
  originalFile = document.getElementById("pdf-file").files[0];
  if (!originalFile) return alert("‚ö†Ô∏è –í—ã–±–µ—Ä–∏—Ç–µ PDF-—Ñ–∞–π–ª.");

  const reader = new FileReader();
  reader.onload = async () => {
    try {
      const bytes = new Uint8Array(reader.result);

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –±–µ–∑–æ–ø–∞—Å–Ω–æ
      await savePDFToDB("pdfRaw", bytes);

      pdfDoc = await pdfjsLib.getDocument({ data: bytes }).promise;
      pageCount = pdfDoc.numPages;
      pageNum = 1;
      document.getElementById("page-count").textContent = pageCount;
      await renderPage(pageNum);
      document.getElementById("save-btn").disabled = false;
    } catch (err) {
      alert("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ PDF: " + err.message);
      console.error(err);
    }
  };

  reader.readAsArrayBuffer(originalFile);
};

  document.getElementById("prev-page").onclick = () => {
    if (pageNum > 1) renderPage(--pageNum);
  };

  document.getElementById("next-page").onclick = () => {
    if (pageNum < pageCount) renderPage(++pageNum);
  };

  document.getElementById("zoom-in").onclick = () => {
    scale = Math.min(scale + 0.2, 3); renderPage(pageNum);
  };

  document.getElementById("zoom-out").onclick = () => {
    scale = Math.max(scale - 0.2, 0.4); renderPage(pageNum);
  };

canvas.addEventListener("click", (e) => {
  const rect = canvas.getBoundingClientRect();
  const canvasX = Math.round((e.clientX - rect.left) * canvas.width / rect.width);
  const canvasY = Math.round((e.clientY - rect.top) * canvas.height / rect.height);

  const relativeX = canvasX / canvas.width;
  const relativeY = canvasY / canvas.height;

  const text = document.getElementById("text-input").value.trim();
  if (!text) return;

  textItems.push({ text, page: pageNum, relativeX, relativeY });
  localStorage.setItem("textItems", JSON.stringify(textItems));
  renderPage(pageNum);
});

  // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –¥–æ–ª–≥–æ–≥–æ –Ω–∞–∂–∞—Ç–∏—è
  canvas.addEventListener("contextmenu", (e) => {
    e.preventDefault(); // –û—Ç–º–µ–Ω—è–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é

    const rect = canvas.getBoundingClientRect();
    const canvasX = Math.round((e.clientX - rect.left) * canvas.width / rect.width);
    const canvasY = Math.round((e.clientY - rect.top) * canvas.height / rect.height);

    // –ò—â–µ–º —ç–ª–µ–º–µ–Ω—Ç –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è
    const indexToRemove = textItems.findIndex(item => 
      Math.abs(item.canvasX - canvasX) < 10 && Math.abs(item.canvasY - canvasY) < 10 && item.page === pageNum
    );

    if (indexToRemove !== -1) {
      console.log(`–£–¥–∞–ª—è–µ–º —Ç–µ–∫—Å—Ç: "${textItems[indexToRemove].text}"`);
      textItems.splice(indexToRemove, 1); // –£–¥–∞–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç
      localStorage.setItem("textItems", JSON.stringify(textItems));
      renderPage(pageNum); // –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É
    } else {
      console.log("–¢–µ–∫—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.");
    }
  });

let draggingItem = null;
let dragOffsetX = 0;
let dragOffsetY = 0;

canvas.addEventListener("mousedown", (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * canvas.width / rect.width;
  const y = (e.clientY - rect.top) * canvas.height / rect.height;

  textItems.forEach(item => {
    if (item.page !== pageNum) return;
    const metrics = ctx.measureText(item.text);
    const w = metrics.width;
    const h = 20; // –ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–∞—è –≤—ã—Å–æ—Ç–∞ —Å—Ç—Ä–æ–∫–∏

    if (x >= item.canvasX && x <= item.canvasX + w &&
        y >= item.canvasY && y <= item.canvasY + h) {
      draggingItem = item;
      dragOffsetX = x - item.canvasX;
      dragOffsetY = y - item.canvasY;
      if (navigator.vibrate) {
  navigator.vibrate(50); // üîî –≤–∏–±—Ä–∞—Ü–∏—è 50 –º—Å
}

    }
  });
});

canvas.addEventListener("mousemove", (e) => {
  if (!draggingItem) return;

  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * canvas.width / rect.width;
  const y = (e.clientY - rect.top) * canvas.height / rect.height;

  draggingItem.canvasX = x - dragOffsetX;
  draggingItem.canvasY = y - dragOffsetY;
  localStorage.setItem("textItems", JSON.stringify(textItems));
  
});

canvas.addEventListener("mouseup", () => {
  draggingItem = null;
  renderPage(pageNum);
});


document.getElementById("save-btn").onclick = async () => {
  try {
    const pdfBytes = await getValidPDFBytes();

    if (!pdfBytes || !(pdfBytes instanceof Uint8Array)) {
      alert("üìõ –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å PDF –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö.");
      console.error("–¢–∏–ø pdfBytes:", typeof pdfBytes);
      return;
    }

    if (textItems.length === 0) {
      alert("‚ÑπÔ∏è –ù–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞.");
      return;
    }

    const doc = await PDFLib.PDFDocument.load(pdfBytes);
    doc.registerFontkit(fontkit);

    const fontBytes = await fetch("https://cdn.jsdelivr.net/npm/dejavu-fonts-ttf@2.37/ttf/DejaVuSans.ttf")
      .then(res => res.arrayBuffer());

    const customFont = await doc.embedFont(fontBytes);
    const pages = doc.getPages();

    for (const item of textItems) {
      const page = pages[item.page - 1];
      const pdfWidth = page.getSize().width;
      const pdfHeight = page.getSize().height;

      const scaleX = pdfWidth / canvas.width;
      const scaleY = pdfHeight / canvas.height;
      let pdfX = item.canvasX * scaleX;
      let pdfY = pdfHeight - item.canvasY * scaleY;

      const lineHeight = 16;
      const maxWidth = 300;
      const words = item.text.split(" ");
      let line = "";

      for (let i = 0; i < words.length; i++) {
        const testLine = line + words[i] + " ";
        const testWidth = customFont.widthOfTextAtSize(testLine, 16);

        if (testWidth > maxWidth && i > 0) {
          page.drawText(line.trim(), {
            x: pdfX,
            y: pdfY,
            font: customFont,
            size: 11,
            color: PDFLib.rgb(0, 0, 0),
          });
          line = words[i] + " ";
          pdfY -= lineHeight;
        } else {
          line = testLine;
        }
      }

      if (line.trim()) {
        page.drawText(line.trim(), {
          x: pdfX,
          y: pdfY,
          font: customFont,
          size: 11,
          color: PDFLib.rgb(0, 0, 0),
        });
      }
    }

    const output = await doc.save();
    const blob = new Blob([output], { type: "application/pdf" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "unicode_texts_precise.pdf";
    link.click();

    setTimeout(() => URL.revokeObjectURL(link.href), 1500);
  } catch (e) {
    alert("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏: " + e.message);
    console.error("–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ PDF –Ω–µ —É–¥–∞–ª–æ—Å—å:", e);
  }
};

document.getElementById("clear-cache").onclick = async () => {
  await clearPDFCache();
  alert("üßπ –ö—ç—à PDF –∏ —Ç–µ–∫—Å—Ç–æ–≤ –æ—á–∏—â–µ–Ω.");
  location.reload(); // üîÑ –æ–±–Ω–æ–≤–ª—è–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É
};
canvas.addEventListener("touchstart", (e) => {
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const x = (touch.clientX - rect.left) * canvas.width / rect.width;
  const y = (touch.clientY - rect.top) * canvas.height / rect.height;

  textItems.forEach(item => {
    if (item.page !== pageNum) return;
    const metrics = ctx.measureText(item.text);
    const w = metrics.width;
    const h = 20;

    if (x >= item.canvasX && x <= item.canvasX + w &&
        y >= item.canvasY && y <= item.canvasY + h) {
      draggingItem = item;
      dragOffsetX = x - item.canvasX;
      dragOffsetY = y - item.canvasY;
      if (navigator.vibrate) {
  navigator.vibrate(50); // üîî –≤–∏–±—Ä–∞—Ü–∏—è 50 –º—Å
}

    }
  });
});
canvas.addEventListener("touchmove", (e) => {
  if (!draggingItem) return;
  e.preventDefault();

  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const x = (touch.clientX - rect.left) * canvas.width / rect.width;
  const y = (touch.clientY - rect.top) * canvas.height / rect.height;

  draggingItem.canvasX = x - dragOffsetX;
  draggingItem.canvasY = y - dragOffsetY;

  
  localStorage.setItem("textItems", JSON.stringify(textItems));
});
canvas.addEventListener("touchend", () => {
  if (draggingItem) {
    draggingItem = null;
    renderPage(pageNum); // –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∞ —Ç–æ–ª—å–∫–æ –≤ –∫–æ–Ω—Ü–µ
  }
});


</script>

</body>
</html>
