<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>PDF Pro Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { font-family: sans-serif; background: #f4f4f4; text-align: center; padding: 1rem; }
    canvas { border: 1px solid #ccc; max-width: 90vw; height: auto; margin-top: 1rem; }
    .controls { margin: 1rem 0; display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center; }
    input, button { padding: 0.5rem; font-size: 1rem; }
    .status { margin-top: 0.5rem; font-size: 1rem; }
    #search-result { margin-top: 0.5rem; color: green; font-size: 1rem; }
  </style>
</head>
<body>
  <h2>üìö PDF PRO –ü—Ä–æ—Å–º–æ—Ç—Ä—â–∏–∫</h2>

  <input type="text" id="pdf-url" placeholder="–í—Å—Ç–∞–≤—å —Å—Å—ã–ª–∫—É –Ω–∞ PDF" size="40" />
  <button onclick="loadFromURL()">–ó–∞–≥—Ä—É–∑–∏—Ç—å PDF</button>
  <button onclick="savePDFLocally()">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å PDF –≤ –±—Ä–∞—É–∑–µ—Ä–µ</button>
  <button onclick="deleteSavedPDF()">üóë –£–¥–∞–ª–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–π PDF</button>

  <div class="controls">
    <button onclick="goToPage(currentPage - 1)">‚¨Ö –ù–∞–∑–∞–¥</button>
    <button onclick="goToPage(currentPage + 1)">–í–ø–µ—Ä—ë–¥ ‚û°</button>
    <input type="number" id="page-input" placeholder="–°—Ç—Ä–∞–Ω–∏—Ü–∞" min="1" />
    <button onclick="jumpToPage()">–ü–µ—Ä–µ–π—Ç–∏</button>
    <button onclick="zoomIn()">üîç+</button>
    <button onclick="zoomOut()">üîé-</button>
    <button onclick="downloadImage()">üíæ PNG</button>
  </div>

  <div class="status">–°—Ç—Ä–∞–Ω–∏—Ü–∞: <span id="current-page">‚Äì</span> / <span id="total-pages">‚Äì</span></div>

  <input type="text" id="search-text" placeholder="–ü–æ–∏—Å–∫ –ø–æ —Ç–µ–∫—Å—Ç—É" />
  <button onclick="searchText()">üîé –ü–æ–∏—Å–∫</button>
  <div id="search-result"></div>

  <canvas id="pdf-canvas"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.6.172/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.6.172/pdf.worker.min.js';

    const canvas = document.getElementById('pdf-canvas');
    const ctx = canvas.getContext('2d');
    let pdfDoc = null;
    let currentPage = 1;
    let totalPages = 0;
    let scale = 1.2;
    let originalBytes = null;

    const currentPageEl = document.getElementById('current-page');
    const totalPagesEl = document.getElementById('total-pages');
    const pageInput = document.getElementById('page-input');
    const searchResultEl = document.getElementById('search-result');

    function convertGitHubBlobToRaw(blobUrl) {
      const match = blobUrl.match(/^https:\/\/github\.com\/([^\/]+)\/([^\/]+)\/blob\/([^\/]+)\/(.+)$/);
      if (!match) return blobUrl;
      const [, user, repo, branch, path] = match;
      return `https://raw.githubusercontent.com/${user}/${repo}/${branch}/${path}`;
    }

    async function openPDFDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open("pdfViewerDB", 1);
        request.onupgradeneeded = e => {
          const db = e.target.result;
          db.createObjectStore("pdfs", { keyPath: "name" });
        };
        request.onsuccess = e => resolve(e.target.result);
        request.onerror = e => reject(e.target.error);
      });
    }

    async function savePDFLocally() {
      if (!originalBytes || originalBytes.length === 0) {
        alert("‚ö†Ô∏è PDF –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω ‚Äî –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å");
        return;
      }
      const blob = new Blob([originalBytes], { type: "application/pdf" });
      const db = await openPDFDB();
      const tx = db.transaction("pdfs", "readwrite");
      tx.objectStore("pdfs").put({ name: "autosaved", data: blob });
      tx.oncomplete = () => alert("‚úÖ PDF —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ –±—Ä–∞—É–∑–µ—Ä–µ");
    }

    async function deleteSavedPDF() {
      const db = await openPDFDB();
      const tx = db.transaction("pdfs", "readwrite");
      tx.objectStore("pdfs").delete("autosaved");
      tx.oncomplete = () => alert("üóë PDF —É–¥–∞–ª—ë–Ω –∏–∑ –ø–∞–º—è—Ç–∏");
    }

    async function loadSavedPDF() {
      const db = await openPDFDB();
      const tx = db.transaction("pdfs", "readonly");
      const store = tx.objectStore("pdfs");
      const request = store.get("autosaved");
      request.onsuccess = async () => {
        const file = request.result?.data;
        if (!file || file.size === 0) return console.warn("–ü—É—Å—Ç–æ–π PDF –≤ –±–∞–∑–µ ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–≥—Ä—É–∑–∫—É");
        const arrayBuffer = await file.arrayBuffer();
        originalBytes = new Uint8Array(arrayBuffer);
        const loading = await pdfjsLib.getDocument(originalBytes).promise;
        pdfDoc = loading;
        totalPages = pdfDoc.numPages;
        totalPagesEl.textContent = totalPages;
        goToPage(1);
      };
    }

    async function loadFromURL() {
      let urlInput = document.getElementById('pdf-url').value.trim();
      if (!urlInput) return alert("–£–∫–∞–∂–∏ —Å—Å—ã–ª–∫—É –Ω–∞ PDF-—Ñ–∞–π–ª");

      const match = urlInput.match(/\/d\/(.+?)\//);
      if (match) {
        urlInput = `https://drive.google.com/uc?export=download&id=${match[1]}`;
      }
      urlInput = convertGitHubBlobToRaw(urlInput);

      try {
        const response = await fetch(urlInput);
        const buffer = await response.arrayBuffer();
        originalBytes = new Uint8Array(buffer);
        const loading = await pdfjsLib.getDocument(originalBytes).promise;
        pdfDoc = loading;
        totalPages = pdfDoc.numPages;
        totalPagesEl.textContent = totalPages;
        goToPage(1);
      } catch (err) {
        alert("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ PDF. –ü—Ä–æ–≤–µ—Ä—å —Å—Å—ã–ª–∫—É –∏–ª–∏ —Ñ–∞–π–ª.");
        console.error(err);
      }
    }

    async function goToPage(pageNumber) {
      if (!pdfDoc || pageNumber < 1 || pageNumber > totalPages) return;
      currentPage = pageNumber;
      currentPageEl.textContent = pageNumber;
      const page = await pdfDoc.getPage(pageNumber);
      const viewport = page.getViewport({ scale });
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      await page.render({ canvasContext: ctx, viewport }).promise;
    }

    function jumpToPage() {
      const target = parseInt(pageInput.value);
      if (!isNaN(target)) goToPage(target);
    }

    function zoomIn() {
      scale = Math.min(scale + 0.2, 3);
      goToPage(currentPage);
    }

    function zoomOut() {
      scale = Math.max(scale - 0.2, 0.4);
      goToPage(currentPage);
    }

    function downloadImage() {
      const link = document.createElement('a');
      link.download = `page-${currentPage}.png`;
      link.href = canvas.toDataURL();
      link.click();
    }

    async function searchText() {
      if (!pdfDoc) return;
      const query = document.getElementById('search-text').value.trim().toLowerCase();
      if (!query) return;
      const page = await pdfDoc.getPage(currentPage);
      const textContent = await page.getTextContent();
      const fullText = textContent.items.map(item => item.str).join(' ').toLowerCase();
      const found = fullText.includes(query);
      searchResultEl.textContent = found
        ? `‚úÖ –ù–∞–π–¥–µ–Ω–æ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ ${currentPage}`
        : `‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–æ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ ${currentPage}`;
    }

    window.addEventListener("DOMContentLoaded", () => {
      loadSavedPDF();
    });
  </script>
</body>
</html>
